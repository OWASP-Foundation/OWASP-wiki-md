## Status

Released 24/4/2007

## Overview

This is a filter to block XSS attacks on PDF files served by Java EE
applications. The details of the attack are discussed
[elsewhere](http://www.gnucitizen.org/blog/danger-danger-danger/). This
filter implements a simple algorithm suggested by Amit Klein. We've
placed this software in the public domain to make it easy for anyone to
use for any purpose. Please let us know if you're using it\!

If you have static PDF files, you may not need this filter. Instead, you
could change MIME type or the Content-Disposition Header as [Adobe
security
advisory](http://www.adobe.com/support/security/advisories/apsa07-02.html).
This will force the user to save the document rather than render it in
the browser window.

## Approach

This attack relies on having some javascript in an anchor after the url
like this:
<http://www.site.com/file.pdf#blah=javascript:alert(document.cookie>);

So the idea is to strip off the anchor. Unfortunately for us, the
browser doesn't send the anchor along with the HTTP request. So we can't
just strip it off.

Therefore, we're going to use a redirect to steer the browser to a link
without the anchor containing the attack. Well, actually it turns out
that we have to overwrite the anchor with something else, so we're going
to use "\#a".

But there's one last problem to overcome. Since the browser doesn't send
the anchor, the new request will look exactly like the request generated
by the redirect. With no way of telling the original request from the
one generated by our redirect, we'll create an infinite loop.

So to differentiate them, we're going to add a temporary token to the
URL in the redirect, which we'll verify when it arrives. We don't want
an attacker forging this token, so we're going to encrypt the user's
source IP address along with a timestamp. If a request shows up for the
PDF file without a valid token, we'll reject it. Or actually, we can
force it to be saved to disk, thus preventing the attack from working.

This way, only an attacker from the same IP address who can trick you
into clicking a link within 10 seconds of creating it can attack you.
Not perfect, but certainly raises the bar quite a bit.

## Download

The source code (one file) and the compiled class file are in a single
zip file.

**[DOWNLOAD](http://www.owasp.org/images/5/59/PDFAttackFilter.zip)**

## Setup

The first step is to add the filter to our application. All we have to
do is put the PDFAttackFilter class on our application's classpath,
probably by putting it in the classes folder in WEB-INF. The class file
should be in a folder structure that matches the package (org -\> owasp
-\> filters -\> PDFAttackFilter). You can extract the class file from
the zip file.

Then we just have to add the following to our web.xml. You should paste
this in right above your servlet definitions. You'll want to change the
mapping so that it only applies to URLs that serve a PDF file. You could
use \*.pdf, but you may have servlets that stream PDF files that don't
end in .pdf.

```
    <filter>
         <filter-name>PDFAttackFilter</filter-name>
         <filter-class>org.owasp.filters.PDFAttackFilter</filter-class>
             <init-param>
                 <param-name>timeoutSeconds</param-name>
                 <param-value>1</param-value>
             </init-param>
             <init-param>
                 <param-name>encryptionPassword</param-name>
                 <param-value>password</param-value>
             </init-param>
             <init-param>
                 <param-name>PDFAttackTokenName</param-name>
                 <param-value>PDFAttackToken</param-value>
             </init-param>
      </filter>

      <filter-mapping>
         <filter-name>PDFAttackFilter</filter-name>
         <url-pattern>/*</url-pattern>
      </filter-mapping>
```

Depending on your application, it may be difficult to map all the URLs
that lead to PDF files. You can map multiple url-patterns to the filter
if necessary. In theory, it might be possible to send the redirect only
if a response with content-type application/pdf. Then you could map the
filter to apply to ALL requests. If there is demand for this feature,
let us know.

## Source Code

This code has been only minimally tested. Please help us verify the
approach and the implementation used here.

    /**
     *  Software published by the Open Web Application Security Project (http://www.owasp.org)
     *  This software is in the public domain with no warranty.
     *
     * @author     Jeff Williams <a href="http://www.aspectsecurity.com">Aspect Security</a>
     * @created    January 4, 2007
     */

    package org.owasp.filters;

    import java.io.IOException;

    import javax.crypto.Cipher;
    import javax.crypto.SecretKey;
    import javax.crypto.SecretKeyFactory;
    import javax.crypto.spec.PBEParameterSpec;
    import javax.servlet.Filter;
    import javax.servlet.FilterChain;
    import javax.servlet.FilterConfig;
    import javax.servlet.ServletException;
    import javax.servlet.ServletRequest;
    import javax.servlet.ServletResponse;
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;

    public class PDFAttackFilter implements Filter
    {

        private static sun.misc.BASE64Decoder decoder = new sun.misc.BASE64Decoder();
        private static sun.misc.BASE64Encoder encoder = new sun.misc.BASE64Encoder();
        private static byte[] salt = { (byte) 0x23, (byte) 0x3f, (byte) 0x28, (byte) 0x00, (byte) 0x11, (byte) 0xc2, (byte) 0xd1, (byte) 0xff };
        private static PBEParameterSpec ps = new PBEParameterSpec( salt, 20 );
        private static SecretKey secretKey;
        private static int timeoutSeconds = 10;
        private static String tokenName = "PDFAttackToken";


        public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException
        {
            HttpServletRequest req = (HttpServletRequest)request;
            HttpServletResponse res = (HttpServletResponse)response;
            String token = req.getParameter( tokenName );

            try
            {

                // IF the URL doesn't contain token, then:
                //  calculate X=encrypt_with_key(server_time, client_IP_address)
                //  redirect to file.pdf?token=X
                //  add #a to the end of the url to eliminate any remaining anchors

                if ( token == null )
                {
                    String etoken = createToken( req );
                    String base = req.getRequestURI();
                    String querystring = req.getQueryString();
                    if ( querystring != null ) base += "?" + req.getQueryString();
                    String appender = base.contains( "?" ) ? "&" : "?";
                    String url = base + appender + tokenName + "=" + etoken + "#a";
                    res.sendRedirect( res.encodeRedirectURL( url ) );
                    return;
                }

                // ELSE IF the URL contains token, then:
                // if decrypt(token_query).IP_address==client_IP_address and
                // decrypt(token_query).time>server_time-10sec
                //  serve the PDF resource as an in-line resource

                if ( checkToken( token, req ) )
                {
                    chain.doFilter(req, res);
                    return;
                }

                // ELSE IF the token doesn't match, then:
                // serve the PDF resource as a "save to disk" resource via a proper
                // choice of the Content-Type header (and/or an attachment, via
                // Content-Disposition).

                res.addHeader("Content-Disposition", "Attachment" );
                res.setContentType( "application/octet" );  // may be overwritten
                chain.doFilter(req, res);
            }
            catch( Exception e )
            {
                throw new ServletException( e );
            }
        }

        public void destroy() {
        }

        public void init(FilterConfig filterConfig) throws ServletException
        {
            try
            {
                String tsparam = filterConfig.getInitParameter("timeoutSeconds");
                timeoutSeconds = Integer.parseInt(tsparam);

                String epparam = filterConfig.getInitParameter("encryptionPassword");
                char[] password = epparam.toCharArray();

                tokenName = filterConfig.getInitParameter("PDFAttackTokenName");

                SecretKeyFactory kf = SecretKeyFactory.getInstance( "PBEWithMD5AndDES" );
                secretKey = kf.generateSecret( new javax.crypto.spec.PBEKeySpec( password ) );
            }
            catch( Exception e )
            {
                throw new ServletException( e );
            }
        }

        public String createToken( HttpServletRequest request ) throws Exception
        {
            String address = request.getRemoteAddr();
            String time = ""+System.currentTimeMillis();
            return encryptString( address + "|" + time );
        }

        public boolean checkToken( String etoken, HttpServletRequest request ) throws Exception
        {
            String token = decryptString( etoken );

            String currentAddress = request.getRemoteAddr();
            String tokenAddress = getAddressFromToken( token );

            long currentTime = System.currentTimeMillis();
            long tokenTime = getTimeFromToken( token );

            return (currentAddress.equals( tokenAddress )) && (tokenTime > currentTime - timeoutSeconds * 1000);
        }

        public String getAddressFromToken( String token )
        {
            String address = token.substring( 0, token.indexOf("|") );
            return address;
        }

        public long getTimeFromToken( String token )
        {
            String date = token.substring( token.indexOf("|") + 1 );
            Long longdate = Long.parseLong( date );
            return longdate.longValue();
        }

        public synchronized String decryptString( String str ) throws Exception
        {
            // Cipher is not threadsafe, so create a new one each time
            Cipher passwordDecryptCipher = Cipher.getInstance( "PBEWithMD5AndDES/CBC/PKCS5Padding" );
            passwordDecryptCipher.init( Cipher.DECRYPT_MODE, secretKey, ps );
            byte[] dec = decoder.decodeBuffer( str.replace( '_', '+') );
            byte[] utf8 = passwordDecryptCipher.doFinal( dec );
            return new String( utf8, "UTF-8" );
        }

        public synchronized String encryptString( String str ) throws Exception
        {
            // Cipher is not threadsafe, so create a new one each time
            Cipher passwordEncryptCipher = Cipher.getInstance( "PBEWithMD5AndDES/CBC/PKCS5Padding" );
            passwordEncryptCipher.init( Cipher.ENCRYPT_MODE, secretKey, ps );
            byte[] utf8 = str.getBytes( "UTF-8" );
            byte[] enc = passwordEncryptCipher.doFinal( utf8 );
            return encoder.encode( enc ).replace( '+', '_' );
        }

    }

## Compile

There are not many dependencies here, just the standard Java EE
environment. You can compile with:

` javac -classpath j2ee.jar -d . *.java`

Then just copy the 'org' folder that gets created to the WEB-INF/classes
folder.

'''Comment: ''' In the decryptString method, it is necessary to strip
the "\#a" from the end of the str parameter, otherwise an
IllegalBlockSizeException will be thrown with "Input length must be
multiple of 8 when decrypting with padded cipher".

[Category:How To](Category:How_To "wikilink")
[Category:Java](Category:Java "wikilink")
[Category:OWASP_Validation_Project](Category:OWASP_Validation_Project "wikilink")
[Category:Countermeasure](Category:Countermeasure "wikilink")
[Category:Control](Category:Control "wikilink")
[Category:FixME/old](Category:FixME/old "wikilink")